"""
This type stub file was generated by pyright.
"""

import asyncio
import contextlib
import functools
import importlib
import inspect
import itertools
import logging
import os
import sys
import time
from concurrent.futures import Future
from queue import Queue
from PyQt5 import QtWidgets
from PyQt5.QtCore import pyqtSlot as Slot
from PyQt6 import QtWidgets
from PyQt6.QtCore import pyqtSlot as Slot
from ._common import with_logger
from ._unix import _SelectorEventLoop
from ._windows import _ProactorEventLoop

"""
Implementation of the PEP 3156 Event-Loop with Qt.

Copyright (c) 2018 Gerard Marull-Paretas <gerard@teslabs.com>
Copyright (c) 2014 Mark Harviston <mark.harviston@gmail.com>
Copyright (c) 2014 Arve Knudsen <arve.knudsen@gmail.com>

BSD License
"""
__all__ = ["QEventLoop", "QThreadExecutor", "asyncSlot", "asyncClose", "asyncWrap"]
logger = ...
QtModule = ...
qtapi_env = ...
if qtapi_env:
    env_to_mod_map = ...
    QtModule = ...
if not QtModule:
    ...
if not QtModule:
    ...
if not QtModule:
    ...
QtCore = ...
QtGui = ...
if QtModuleName == "PyQt5":
    QApplication = ...
    AllEvents = ...
else:
    QApplication = ...
    AllEvents = ...
@with_logger
class _QThreadWorker(QtCore.QThread):
    """
    Read jobs from the queue and then execute them.

    For use by the QThreadExecutor
    """
    def __init__(self, queue, num, stackSize=...) -> None:
        ...
    
    def run(self): # -> None:
        ...
    
    def wait(self): # -> None:
        ...
    


@with_logger
class QThreadExecutor:
    """
    ThreadExecutor that produces QThreads.

    Same API as `concurrent.futures.Executor`

    >>> from qasync import QThreadExecutor
    >>> with QThreadExecutor(5) as executor:
    ...     f = executor.submit(lambda x: 2 + x, 2)
    ...     r = f.result()
    ...     assert r == 4
    """
    def __init__(self, max_workers=..., stack_size=...) -> None:
        ...
    
    def submit(self, callback, *args, **kwargs): # -> Future[Any]:
        ...
    
    def map(self, func, *iterables, timeout=...):
        ...
    
    def shutdown(self, wait=...): # -> None:
        ...
    
    def __enter__(self, *args): # -> Self:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    


@with_logger
class _SimpleTimer(QtCore.QObject):
    def __init__(self) -> None:
        ...
    
    def add_callback(self, handle, delay=...):
        ...
    
    def timerEvent(self, event): # -> None:
        ...
    
    def stop(self): # -> None:
        ...
    
    def set_debug(self, enabled): # -> None:
        ...
    


@with_logger
class _QEventLoop:
    """
    Implementation of asyncio event loop that uses the Qt Event loop.

    >>> import asyncio
    >>>
    >>> app = getfixture('application')
    >>>
    >>> async def xplusy(x, y):
    ...     await asyncio.sleep(.1)
    ...     assert x + y == 4
    ...     await asyncio.sleep(.1)
    >>>
    >>> asyncio.run(xplusy(2, 2), loop_factory=lambda:QEventLoop(app))

    If the event loop shall be used with an existing and already running QApplication
    it must be specified in the constructor via already_running=True
    In this case the user is responsible for loop cleanup with stop() and close()

    The set_running_loop parameter is there for backwards compatibility and does nothing.
    """
    def __init__(self, app=..., set_running_loop=..., already_running=...) -> None:
        ...
    
    def run_forever(self): # -> int:
        """Run eventloop forever."""
        ...
    
    def run_until_complete(self, future):
        """Run until Future is complete."""
        ...
    
    def stop(self): # -> None:
        """Stop event loop."""
        ...
    
    def is_running(self): # -> bool:
        """Return True if the event loop is running, False otherwise."""
        ...
    
    def close(self): # -> None:
        """
        Release all resources used by the event loop.

        The loop cannot be restarted after it has been closed.
        """
        ...
    
    def call_later(self, delay, callback, *args, context=...):
        """Register callback to be invoked after a certain delay."""
        ...
    
    def call_soon(self, callback, *args, context=...):
        """Register a callback to be run on the next iteration of the event loop."""
        ...
    
    def call_at(self, when, callback, *args, context=...):
        """Register callback to be invoked at a certain time."""
        ...
    
    def time(self): # -> float:
        """Get time according to event loop's clock."""
        ...
    
    def call_soon_threadsafe(self, callback, *args, context=...): # -> None:
        """Thread-safe version of call_soon."""
        ...
    
    def run_in_executor(self, executor, callback, *args): # -> Future[Any]:
        """Run callback in executor.

        If no executor is provided, the default executor will be used, which defers execution to
        a background thread.
        """
        ...
    
    def set_default_executor(self, executor): # -> None:
        ...
    
    def set_exception_handler(self, handler): # -> None:
        ...
    
    def default_exception_handler(self, context): # -> None:
        """Handle exceptions.

        This is the default exception handler.

        This is called when an exception occurs and no exception
        handler is set, and can be called by a custom exception
        handler that wants to defer to the default behavior.

        context parameter has the same meaning as in
        `call_exception_handler()`.
        """
        ...
    
    def call_exception_handler(self, context): # -> None:
        ...
    
    def get_debug(self): # -> bool:
        ...
    
    def set_debug(self, enabled): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    


QSelectorEventLoop = ...
if os.name == "nt":
    QIOCPEventLoop = ...
    QEventLoop = QIOCPEventLoop
else:
    ...
class _Cancellable:
    def __init__(self, timer, loop) -> None:
        ...
    
    def cancel(self): # -> None:
        ...
    


def asyncClose(fn): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], None]:
    """Allow to run async code before application is closed."""
    ...

def asyncSlot(*args, **kwargs): # -> Callable[..., _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]]:
    """Make a Qt async slot run on asyncio loop."""
    ...

async def asyncWrap(fn, *args, **kwargs):
    """
    Wrap a blocking function as an asynchronous and run it on the native Qt event loop.
    The function will be scheduled using a one shot QTimer which prevents blocking the
    QEventLoop. An example usage of this is raising a modal dialogue inside an asyncSlot.
    ```python
    async def before_shutdown(self):
        await asyncio.sleep(2)

    @asyncSlot()
    async def shutdown_clicked(self):
        # do some work async
        asyncio.create_task(self.before_shutdown())

        # run on the native Qt loop, not blocking the QEventLoop
        result = await asyncWrap(
            lambda: QMessageBox.information(None, "Done", "It is now safe to shutdown.")
        )
        if result == QMessageBox.StandardButton.Ok:
            app.exit(0)
    ```
    """
    ...

if sys.version_info >= (3, 12):
    def run(*args, **kwargs):
        ...
    
else:
    ...
